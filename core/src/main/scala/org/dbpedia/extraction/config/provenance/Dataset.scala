package org.dbpedia.extraction.config.provenance

import java.net.URI
import java.util.MissingFormatArgumentException

import org.dbpedia.extraction.config.ConfigUtils
import org.dbpedia.extraction.ontology.{DBpediaNamespace, RdfNamespace}
import org.dbpedia.extraction.util.{Language, WikiUtil}
import org.dbpedia.extraction.wikiparser.WikiParserException
import org.dbpedia.iri.{IRI, UriUtils}

import scala.util.{Failure, Success, Try}

/**
 * The quads generated by the DBpedia framework are organized in a number of datasets.
 */
class Dataset private[provenance](
   naturalName: String, //The title of the dataset
   descr: String = null, //The description used for documentation
   lang: Language = null, //The language (when dealing with a language specific version of the dataset)
   versionEntry: String = null, //The DBpedia version of the Dataset (e.g. 2016-04). If supplied this dataset is specific to (language and) DBpedia version.
   fileName: String = null, //The name of this Dataset used in file names and uris (if null this will generated form the naturalName)
   var sources: Seq[Dataset] = Seq.empty[Dataset], //The Datasets out of which this dataset was extracted/generated...
   result: String = null, //Uri of the Extractor/script which produced this dataset (see class DBpediaAnnotations)
   input: Seq[String] = Seq.empty[String], //Uris of the Extractors/scripts which use this dataset as in input (see class DBpediaAnnotations)
   depr: String = null, //last DBpedia version the dataset was in use (and now deprecated): e.g. 2015-10
   var traits: DatasetTrait.ValueSet = DatasetTrait.ValueSet.empty, //The set of traits the dataset has. According to these traits a dataset will be post-processed.
   defaultGraf: String = "dataset", //The default graph name is usually the language specific dbpedia namespace IRI.
   // With this extension you can add to the path of this IRI to define secondary graphs .
    // reserved values:
   //       'namespace' -> the dataset is part of the general namespace of this language (for general datasets which form the main knowledge graph of this language)
   //       'dataset'   -> the language namespace is appended with the name of the current dataset (forming an alternate graph iri -> indicating that the dataset has a singular purpose, but should not appear in the general knowledge graph)
   //       'any other value (no whitespaces!)' -> is appended to the namespace of this language (see above -> this can be used to crete alternative namespaces stretching over multiple datasets)
   var keywords: Seq[String] = Seq.empty[String] //also for documentation
   ) extends java.io.Serializable
{

  val description = Option(descr)
  val language = Option(lang)

  val inputFor: Seq[Try[IRI]] = input.map(x => UriUtils.createURI(x))

  val resultOf: Try[IRI] = Option(result) match{
    case Some(u) => UriUtils.createURI(u)
    case None => Failure(new IllegalArgumentException("No target class for inputFor provided."))
  }

  val name: String = WikiUtil.wikiDecode(naturalName.trim)
  if (name.isEmpty) throw new WikiParserException("dataset name must not be empty")

  /** Wiki-encoded dataset name */
  val encoded: String = WikiUtil.wikiEncode((if(Option(fileName).nonEmpty && fileName.trim.nonEmpty) fileName.trim else name).replace("-", "_")).toLowerCase

  val filenameEncoded: String = encoded.replace("_", "-")

  val canonicalUri: String = RdfNamespace.fullUri(DBpediaNamespace.DATASET, encoded)

  val version: Try[String] = ConfigUtils.parseVersionString(versionEntry)

  val deprecatedSince: Try[String] = ConfigUtils.parseVersionString(depr)

  lazy val canonicalVersion: Dataset = if(isCanonical) this else copyDataset(lang = null, versionEntry = null)

  def getLanguageVersion(language: Language, version: String = null): Try[Dataset] ={
    if(this.language.isEmpty || this.language.get == language) {
      Success(ConfigUtils.parseVersionString(version) match {
        case Success(v) => this.copyDataset(lang = language, versionEntry = v)
        case Failure(e) => this.copyDataset(lang = language)
      })
    }
    else
      Failure(new IllegalArgumentException("The target Dataset is already language specific: " + this.language.get.name + ". Conversion to other languages is therefore not permitted."))
  }

  def languageUri: String = this.language match{
    case Some(lang) => canonicalUri + "?lang=" + lang.wikiCode
    case None => canonicalUri
  }

  def versionUri: String = this.language match {
    case Some(l) => version match
    {
      case Success(v) => this.languageUri + "&dbpv=" + v
      case Failure(e) => this.languageUri
    }
    case None => canonicalUri
  }

  def isCanonical: Boolean = language match {
    case Some(lang) => false
    case None => true
  }

  def getDistributionUri(distType: String, extension: String): String ={
    val lang = this.language match{
      case Some(l) => l
      case None => throw new MissingFormatArgumentException("Dataset is language unspecific and can therefore not provide distribution URIs. Please specify a language first!.")
    }
    this.versionUri + "&" + distType  + "=" + this.encoded +"_" + lang.wikiCode + extension
  }

  def getRelationUri(role: String, target: Dataset): String ={
    val lang = this.language match{
      case Some(l) => l
      case None => throw new MissingFormatArgumentException("Dataset is language unspecific and can therefore not provide dataset relation URIs. Please specify a language first!.")
    }
    if(role.matches("\\w+") && target.language.nonEmpty)
      this.versionUri + "&relation=" + role + "&target=" + target.encoded
    else
      throw new MissingFormatArgumentException("Target dataset is language unspecific and can therefore not provide dataset relation URIs. Please specify a language first!.")
  }

  def defaultGraph: Option[String] = {
    def appendNamespaceByTrait(ns: String): String = {
      var ret = ns
      this.traits.foreach {
        case DatasetTrait.Unredirected => ret += "/unredirected"
        case DatasetTrait.EnglishUris => ret += "/en_uris"
        case DatasetTrait.WikidataUris => ret += "/wkd_uris"
        case _ =>
      }
      ret
    }
    this.language match {
      case Some(l) => Option(this.defaultGraf) match{
        case Some(dg) =>
          val namespace = if(l == Language.English) l.dbpediaUri.replace("en.", "") else l.dbpediaUri
          dg.trim match{
          case str if str == "namespace" => Some(appendNamespaceByTrait(namespace))
          case str if str == "dataset" => Some(appendNamespaceByTrait(namespace) + "/" + this.encoded)
          case str if str.trim.matches("(\\w|-|_)+") => Some(appendNamespaceByTrait(l.dbpediaUri) + "/" + str.trim.toLowerCase())
          case _ => throw new IllegalArgumentException("Default graph entry is missing or malformed for dataset: " + this.encoded)
        }
        case None => throw new IllegalArgumentException("Default graph entry is missing or malformed for dataset: " + this.encoded)
      }
      case None => None
    }
  }

  def isLinkedDataDataset: Boolean = traits.contains(DatasetTrait.LinkedData)

  override def toString: String = encoded

  override def hashCode: Int = encoded.hashCode

  override def equals(other : Any): Boolean = other match {
    case that: Dataset => this.encoded == that.encoded
    case _ => false
  }

  //maybe extend scope but keep this as closed as possible
  private[provenance] def copyDataset(
     naturalName: String = this.naturalName,
     descr: String = this.descr,
     lang: Language = this.lang,
     versionEntry: String = this.versionEntry,
     fileName: String = this.fileName,
     sources: Seq[Dataset] = this.sources,
     result: String = this.result,
     input: Seq[String] = this.input,
     depr: String = this.depr,
     traits: DatasetTrait.ValueSet = this.traits,
     defaultGraphExt: String = this.defaultGraf,
     keywords: Seq[String] = this.keywords
  ) : Dataset = new Dataset(
      naturalName,
      descr,
      lang,
      versionEntry,
      fileName,
      sources,
      result,
      input,
      depr,
      traits,
      defaultGraphExt,
      keywords
  )
}
